<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gender Reveal App</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
</head>

<body class="bg-gray-50 flex items-center justify-center min-h-screen p-4">
  <div id="app" class="w-full max-w-md mx-auto bg-white rounded-2xl shadow-xl border border-gray-200 overflow-hidden">
    <!-- Upload feedback banner -->
    <div v-if="uploadSuccess" class="p-4 bg-emerald-50 border-b border-emerald-100 text-emerald-800 flex items-center justify-between">
      <div>
        <strong class="block text-sm font-semibold">Upload successful</strong>
        <a :href="uploadedUrl" target="_blank" class="underline text-xs hover:text-emerald-900">View uploaded video</a>
      </div>
      <button @click="uploadSuccess = false" class="text-xs px-3 py-1 bg-emerald-100 hover:bg-emerald-200 rounded-lg font-medium transition-colors">Dismiss</button>
    </div>

    <!-- Uploading indicator -->
    <div v-if="uploadLoading" class="p-4 bg-amber-50 border-b border-amber-100 text-amber-800 flex items-center gap-3">
      <svg class="h-4 w-4 animate-spin text-amber-600" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-opacity="0.25" stroke-width="4"></circle>
        <path d="M22 12a10 10 0 00-10-10" stroke="currentColor" stroke-width="4" stroke-linecap="round"></path>
      </svg>
      <div class="text-sm font-medium">Uploading videoâ€¦</div>
    </div>

    <!-- Countdown overlay (3..2..1) -->
    <div v-if="showCountdown" class="absolute inset-0 bg-gray-900/80 z-50 flex items-center justify-center pointer-events-none rounded-2xl">
      <div class="text-white text-6xl sm:text-8xl font-bold animate-pulse">
        {{ countdown }}
      </div>
    </div>

    <!-- Main content area -->
    <div class="p-6">
      <div v-if="step === 'permission'" class="flex flex-col items-center space-y-8 py-8">
        <div class="text-5xl">ğŸ“¹</div>
        <div class="text-center space-y-3">
          <h1 class="text-2xl font-bold text-gray-900">Welcome to the Gender Reveal!</h1>
          <p class="text-gray-600 leading-relaxed">We'll record your reaction and voice during this fun reveal experience.</p>
          <p class="text-sm text-gray-500">Recording will begin automatically after you allow camera access.</p>
        </div>
        <button @click="allowAndStart" class="w-full py-4 bg-gray-900 hover:bg-gray-800 text-white rounded-xl text-lg font-semibold transition-all duration-200 shadow-lg hover:shadow-xl">
          Allow Camera & Continue
        </button>
      </div>

      <div v-else-if="step === 'guess'" class="flex flex-col items-center space-y-8 py-6">
        <div class="text-center space-y-2">
          <h2 class="text-2xl font-bold text-gray-900">Make Your Guess!</h2>
          <p class="text-gray-600">What do you think the baby will be?</p>
        </div>
        
        <div class="flex w-full space-x-4">
          <button @click="choose('girl')" :disabled="choosingGender"
            :class="choosingGender ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105 hover:shadow-lg'"
            class="flex-1 py-6 bg-pink-300 hover:bg-pink-400 text-white rounded-xl text-xl font-bold transition-all duration-200 shadow-md">
            <span v-if="choosingGender && chosenGender === 'girl'" class="flex items-center justify-center gap-2">
              <svg class="h-5 w-5 animate-spin" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-opacity="0.25" stroke-width="4"></circle>
                <path d="M22 12a10 10 0 00-10-10" stroke="currentColor" stroke-width="4" stroke-linecap="round"></path>
              </svg>
              Saving...
            </span>
            <span v-else class="flex flex-col items-center gap-2">
              <span class="text-2xl">ğŸ‘§</span>
              Girl
            </span>
          </button>
          <button @click="choose('boy')" :disabled="choosingGender"
            :class="choosingGender ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105 hover:shadow-lg'"
            class="flex-1 py-6 bg-blue-300 hover:bg-blue-400 text-white rounded-xl text-xl font-bold transition-all duration-200 shadow-md">
            <span v-if="choosingGender && chosenGender === 'boy'" class="flex items-center justify-center gap-2">
              <svg class="h-5 w-5 animate-spin" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-opacity="0.25" stroke-width="4"></circle>
                <path d="M22 12a10 10 0 00-10-10" stroke="currentColor" stroke-width="4" stroke-linecap="round"></path>
              </svg>
              Saving...
            </span>
            <span v-else class="flex flex-col items-center gap-2">
              <span class="text-2xl">ğŸ‘¦</span>
              Boy
            </span>
          </button>
        </div>
        
        <!-- Gender choice feedback -->
        <div v-if="chosenGender && !choosingGender" class="w-full p-6 rounded-xl border-2 border-dashed transition-all duration-300" 
             :class="chosenGender === 'girl' ? 'bg-pink-50 border-pink-200 text-pink-700' : 'bg-blue-50 border-blue-200 text-blue-700'">
          <div class="text-center space-y-3">
            <div class="text-3xl">{{ chosenGender === 'girl' ? 'ğŸ‘§' : 'ğŸ‘¦' }}</div>
            <div class="font-bold text-lg">You guessed: {{ chosenGender === 'girl' ? 'Girl' : 'Boy' }}!</div>
            <div class="text-sm opacity-80">Great choice! Let's see how others voted...</div>
          </div>
        </div>
        
        <button v-if="chosenGender && !choosingGender" @click="nextStep" 
                class="w-full py-4 bg-gray-900 hover:bg-gray-800 text-white rounded-xl text-lg font-semibold transition-all duration-200 shadow-lg hover:shadow-xl">
          Continue to Results
        </button>
      </div>

      <div v-else-if="step === 'stats'" class="flex flex-col items-center space-y-8 py-6">
        <div class="text-center space-y-2">
          <h2 class="text-2xl font-bold text-gray-900">Current Predictions</h2>
          <p class="text-gray-600">Here's what everyone is thinking...</p>
        </div>
        
        <div class="w-full bg-gray-50 rounded-xl p-6">
          <div class="flex justify-around">
            <div class="flex flex-col items-center space-y-2">
              <div class="text-blue-400 text-3xl font-bold">{{ stats.boy }}%</div>
              <div class="text-gray-700 font-medium flex items-center gap-1">
                <span class="text-lg">ğŸ‘¦</span>
                Boy
              </div>
            </div>
            <div class="w-px bg-gray-200"></div>
            <div class="flex flex-col items-center space-y-2">
              <div class="text-pink-400 text-3xl font-bold">{{ stats.girl }}%</div>
              <div class="text-gray-700 font-medium flex items-center gap-1">
                <span class="text-lg">ğŸ‘§</span>
                Girl
              </div>
            </div>
          </div>
        </div>
        
        <button @click="startSuspenseReveal" :disabled="suspenseActive" 
                class="w-full py-4 bg-gray-900 hover:bg-gray-800 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-xl text-lg font-semibold transition-all duration-200 shadow-lg hover:shadow-xl">
          {{ suspenseActive ? 'Revealing...' : 'ğŸ‰ Ready for the Big Reveal?' }}
        </button>
      </div>

      <div v-else-if="step === 'suspense'" class="flex flex-col items-center space-y-8 py-6">
        <div class="text-center">
          <h2 class="text-xl font-bold animate-pulse text-center" :class="suspenseTextColor">
            {{ suspenseText }}
          </h2>
        </div>
        
        <!-- Drumroll indicator -->
        <div v-if="showDrumroll" class="text-center animate-bounce">
          <div class="text-5xl">ğŸ¥</div>
          <div class="text-sm text-gray-500 mt-2 font-medium">*drumroll intensifies*</div>
        </div>
        
        <!-- Suspenseful options display -->
        <div class="w-full space-y-4">
          <div v-show="showBoyOption" 
               class="w-full p-8 rounded-xl text-center transition-all duration-1000 transform border-2"
               :class="boyOptionActive ? 'bg-blue-50 border-blue-300 scale-105 shadow-lg animate-pulse' : 'bg-gray-100 border-gray-200 opacity-30 scale-95'">
            <div class="text-4xl mb-3">ğŸ‘¦</div>
            <div class="text-2xl font-bold text-blue-400">BOY?</div>
            <div v-if="boyOptionActive" class="text-sm text-blue-400 mt-2 animate-pulse font-medium">Could it be?</div>
          </div>
          
          <div v-show="showGirlOption" 
               class="w-full p-8 rounded-xl text-center transition-all duration-1000 transform border-2"
               :class="girlOptionActive ? 'bg-pink-50 border-pink-300 scale-105 shadow-lg animate-pulse' : 'bg-gray-100 border-gray-200 opacity-30 scale-95'">
            <div class="text-4xl mb-3">ğŸ‘§</div>
            <div class="text-2xl font-bold text-pink-400">GIRL?</div>
            <div v-if="girlOptionActive" class="text-sm text-pink-400 mt-2 animate-pulse font-medium">Or maybe this?</div>
          </div>
        </div>
        
        <!-- Tension building elements -->
        <div v-if="showTensionDots" class="flex justify-center space-x-2">
          <div class="w-3 h-3 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0s;"></div>
          <div class="w-3 h-3 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s;"></div>
          <div class="w-3 h-3 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.4s;"></div>
        </div>
      </div>

      <div v-else-if="step === 'reveal'" class="flex flex-col items-center space-y-8 py-8">
        <div class="text-center">
          <div v-if="reveal === 'girl'" class="space-y-4">
            <div class="text-pink-400 text-4xl sm:text-6xl font-bold animate-bounce">
              ğŸ‰ IT'S A GIRL! ğŸ‰
            </div>
            <div class="text-2xl text-pink-400 font-semibold">Congratulations!</div>
          </div>
          <div v-else class="space-y-4">
            <div class="text-blue-400 text-4xl sm:text-6xl font-bold animate-bounce">
              ğŸ‰ IT'S A BOY! ğŸ‰
            </div>
            <div class="text-2xl text-blue-400 font-semibold">Congratulations!</div>
          </div>
        </div>
        <button @click="finishAndUpload"
          class="w-full py-4 bg-gray-900 hover:bg-gray-800 text-white rounded-xl text-lg font-semibold transition-all duration-200 shadow-lg hover:shadow-xl">
          Finish & Save Recording
        </button>
      </div>

      <div v-else-if="step === 'end'" class="flex flex-col items-center space-y-8 py-12">
        <div class="text-6xl">ğŸŠ</div>
        <div class="text-center space-y-3">
          <h2 class="text-2xl font-bold text-gray-900">Thank You!</h2>
          <p class="text-gray-600">Thanks for being part of this special moment!</p>
        </div>
      </div>
    </div>

    <!-- persistent top-right cam: visible when stream is available -->
    <div class="fixed top-6 right-6 z-50" v-show="stream">
      <div class="flex flex-col items-center space-y-2">
        <div id="camHolder" class="w-20 h-20 bg-gray-200 rounded-2xl overflow-hidden flex items-center justify-center shadow-lg border-2 border-white">
          <video id="miniCam" autoplay playsinline muted class="object-cover w-full h-full"></video>
        </div>
        <div class="text-xs text-gray-600 bg-white px-2 py-1 rounded-lg shadow-sm font-medium">{{ uploadStatus }}</div>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;
    // Supabase config â€” reuse your project values
    const SUPABASE_URL = "https://ojgmqxidefvwxhkgkwbr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9qZ21xeGlkZWZ2d3hoa2drd2JyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxNzA1MTEsImV4cCI6MjA3MDc0NjUxMX0.D73zLIQvXzQ-pofnkVPpci-Q5J97WZ06MWsI6mL9bcM";
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    createApp({
      data() {
        return {
          step: 'permission',
          stats: { boy: 0, girl: 0 },
          reveal: 'girl',
          chosenGender: null,
          choosingGender: false,
          // suspense reveal state
          suspenseActive: false,
          suspenseText: '',
          suspenseTextColor: 'text-gray-700',
          showBoyOption: false,
          showGirlOption: false,
          boyOptionActive: false,
          girlOptionActive: false,
          showDrumroll: false,
          showTensionDots: false,
          // active MediaStream
          stream: null,
          // recording state
          isRecording: false,
          mediaRecorder: null,
          videoChunks: [],
          uploadStatus: '',
          clientId: null,
          // internal upload synchronization
          _uploadDone: null,
          _resolveUpload: null,
          // upload feedback
          uploadSuccess: false,
          uploadedUrl: '',
          uploadMessage: '',
          uploadLoading: false,
          // countdown state
          showCountdown: false,
          countdown: 3,
        }
      },
      methods: {
        nextStep() {
          if (this.step === 'permission') this.step = 'guess';
          else if (this.step === 'guess') this.step = 'stats';
          else if (this.step === 'stats') this.step = 'suspense';
          else if (this.step === 'suspense') this.step = 'reveal';
          else if (this.step === 'reveal') this.step = 'end';
          
          // Load stats when entering the stats step
          if (this.step === 'stats') {
            this.loadGenderStats();
          }
        },
        async loadGenderStats() {
          try {
            const { data: users, error } = await supabaseClient
              .from('users')
              .select('gender')
              .not('gender', 'is', null);
            
            if (!error && users && users.length > 0) {
              const total = users.length;
              const boyCount = users.filter(u => u.gender === 'boy').length;
              const girlCount = users.filter(u => u.gender === 'girl').length;
              
              this.stats.boy = total ? Math.round((boyCount / total) * 100) : 0;
              this.stats.girl = total ? Math.round((girlCount / total) * 100) : 0;
            } else {
              this.stats.boy = 50;
              this.stats.girl = 50;
            }
          } catch (err) {
            console.error('Error loading gender stats:', err);
            // Fallback to default values
            this.stats.boy = 50;
            this.stats.girl = 50;
          }
        },
        async startSuspenseReveal() {
          this.suspenseActive = true;
          this.step = 'suspense';
          
          // Get actual reveal gender from settings
          try {
            const { data, error } = await supabaseClient.from('settings').select('gender').single();
            if (data && data.gender) {
              this.reveal = data.gender;
            }
          } catch (err) {
            console.error('Error fetching reveal gender:', err);
          }
          
          // Suspense sequence
          await this.runSuspenseSequence();
        },
        
        async runSuspenseSequence() {
          // Step 1: Initial suspense building
          this.suspenseText = "The moment you've all been waiting for...";
          this.suspenseTextColor = 'text-gray-700';
          await this.delay(2500);
          
          this.suspenseText = "Are you ready to find out?";
          this.suspenseTextColor = 'text-gray-900';
          await this.delay(2000);
          
          this.suspenseText = "Take a deep breath...";
          this.suspenseTextColor = 'text-gray-800';
          await this.delay(2000);
          
          // Step 2: Building more tension
          this.suspenseText = "The baby is...";
          this.suspenseTextColor = 'text-gray-900';
          this.showDrumroll = true;
          await this.delay(3000);
          
          this.showDrumroll = false;
          this.suspenseText = "Is it a...";
          this.suspenseTextColor = 'text-gray-800';
          await this.delay(1500);
          
          // Step 3: Show Boy option with more drama
          this.suspenseText = "BOY?";
          this.suspenseTextColor = 'text-blue-400';
          this.showBoyOption = true;
          this.boyOptionActive = true;
          await this.delay(2500);
          
          this.suspenseText = "Hmm... or maybe not?";
          this.suspenseTextColor = 'text-gray-600';
          this.boyOptionActive = false;
          await this.delay(1500);
          
          // Step 4: Show Girl option with suspense
          this.suspenseText = "What about... a GIRL?";
          this.suspenseTextColor = 'text-pink-400';
          this.showGirlOption = true;
          this.girlOptionActive = true;
          await this.delay(2500);
          
          this.suspenseText = "Or... wait for it...";
          this.suspenseTextColor = 'text-gray-700';
          this.girlOptionActive = false;
          await this.delay(1500);
          
          // Step 5: Final dramatic build-up
          this.suspenseText = "The moment of truth is here!";
          this.suspenseTextColor = 'text-gray-900';
          this.showTensionDots = true;
          await this.delay(3000);
          
          this.suspenseText = "And the answer is...";
          this.suspenseTextColor = 'text-gray-900';
          this.showTensionDots = false;
          await this.delay(2000);
          
          // Reset all suspense elements before reveal
          this.showBoyOption = false;
          this.showGirlOption = false;
          this.showDrumroll = false;
          this.showTensionDots = false;
          await this.delay(500);
          
          // Move to reveal
          this.nextStep();
        },
        delay(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        },
        async choose(gender) {
          this.choosingGender = true;
          this.chosenGender = gender;
          
          try {
            // Save gender to database
            const { error } = await supabaseClient
              .from('users')
              .update({ gender: gender })
              .eq('unique_link', this.clientId);

            if (error) {
              console.error('Error saving gender:', error);
              // Reset on error
              this.chosenGender = null;
              alert('Failed to save your choice. Please try again.');
            }
          } catch (err) {
            console.error('Exception saving gender:', err);
            // Reset on error
            this.chosenGender = null;
            alert('Failed to save your choice. Please try again.');
          } finally {
            this.choosingGender = false;
          }
          
          this.reveal = gender;
          // Don't automatically advance to next step - let user click Continue button
        },
        // Called when user clicks "Allow & Continue" â€” reuse stream if already granted on mount,
        // otherwise request permission and then run countdown/start recording
        async allowAndStart() {
          try {
            this.uploadStatus = 'Preparing cameraâ€¦';
            if (!this.stream) {
              // request permission if not already granted on mount
              this.stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
              // attach preview if miniCam already rendered
              await this.$nextTick();
              const mini = document.getElementById('miniCam');
              if (mini) mini.srcObject = this.stream;
            }
            // start the visible 3..2..1 countdown before showing the guess screen
            this.startCountdown(3);
          } catch (err) {
            console.error('Camera init error:', err);
            this.uploadStatus = 'Camera permission denied or unavailable';
          }
        },

        // run a numeric countdown (seconds) then show guess and start recording
        startCountdown(seconds = 3) {
          this.countdown = seconds;
          this.showCountdown = true;
          const tick = () => {
            if (this.countdown > 1) {
              this.countdown--;
              setTimeout(tick, 1000);
            } else {
              // last tick -> hide overlay, show guess and start recording
              this.showCountdown = false;
              this.nextStep(); // move to 'guess'
              this.$nextTick(() => {
                const mini = document.getElementById('miniCam');
                if (mini) mini.srcObject = this.stream;
                // prepare recorder if not already
                if (!this.mediaRecorder) {
                  this.mediaRecorder = new MediaRecorder(this.stream, { mimeType: 'video/webm' });
                  this.mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) this.videoChunks.push(e.data); };
                  this.mediaRecorder.onstop = () => this.uploadRecordedVideo();
                }
                this.startRecord();
              });
            }
          };
          // initial delay 1s then begin ticks so "3" appears for ~1s
          setTimeout(tick, 1000);
        },
        async initCamera() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            // set small cam preview
            const miniCam = document.getElementById('miniCam');
            if (miniCam) miniCam.srcObject = stream;
            // prepare recorder but don't start yet
            this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            this.mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) this.videoChunks.push(e.data); };
            this.mediaRecorder.onstop = () => this.uploadRecordedVideo();
          } catch (err) {
            console.error('Camera init error:', err);
            this.uploadStatus = 'Camera unavailable';
            throw err;
          }
        },
        startRecord() {
          if (!this.mediaRecorder) {
            this.uploadStatus = 'Camera not initialized';
            return;
          }
          this.videoChunks = [];
          this.mediaRecorder.start();
          this.isRecording = true;
          this.uploadStatus = 'Recordingâ€¦';
        },
        stopRecord() {
          if (!this.mediaRecorder || !this.isRecording) return;
          this.mediaRecorder.stop();
          this.isRecording = false;
          this.uploadStatus = 'Stoppingâ€¦';
        },
        async uploadRecordedVideo() {
          // create a promise so callers (finishAndUpload) can await upload completion
          this.uploadStatus = 'Uploadingâ€¦';
          this.uploadLoading = true;
          this._uploadDone = new Promise((resolve) => { this._resolveUpload = resolve; });
          try {
            const blob = new Blob(this.videoChunks, { type: 'video/webm' });
            const timestamp = Date.now();
            const idPart = this.clientId ? `${this.clientId}/` : '';
            const fileName = `${idPart}${timestamp}.webm`;
            const path = `recordings/${fileName}`;
            const file = new File([blob], `${timestamp}.webm`, { type: 'video/webm' });
            const res = await supabaseClient.storage.from('videos').upload(path, file, { upsert: false });
            const error = res.error || (res?.data && res?.data?.error);
            if (error) {
              console.error('Upload error:', error, res);
              this.uploadStatus = 'Upload failed: ' + (error.message || JSON.stringify(error));
              this.uploadSuccess = false;
              this.uploadMessage = this.uploadStatus;
              this._resolveUpload && this._resolveUpload();
              return;
            }
            const { data: pub } = supabaseClient.storage.from('videos').getPublicUrl(path);
            this.uploadStatus = `Uploaded`;
            this.uploadSuccess = true;
            this.uploadedUrl = pub.publicUrl;
            this.uploadMessage = 'Upload successful';
            // auto-hide banner after 8s
            setTimeout(() => { this.uploadSuccess = false; }, 8000);
            this._resolveUpload && this._resolveUpload();
          } catch (err) {
            console.error('Upload exception:', err);
            this.uploadStatus = 'Upload failed: ' + (err.message || JSON.stringify(err));
            this.uploadSuccess = false;
            this.uploadMessage = this.uploadStatus;
            this._resolveUpload && this._resolveUpload();
          } finally {
            this.uploadLoading = false;
            this._uploadDone = null;
            this._resolveUpload = null;
          }
        },
        // Called when the user presses Finish: stop recording if active, wait for upload, then proceed
        async finishAndUpload() {
          try {
            if (this.isRecording && this.mediaRecorder) {
              this.uploadStatus = 'Stopping and uploadingâ€¦';
              this.mediaRecorder.stop();
              this.isRecording = false;
              // wait for uploadRecordedVideo to finish (resolves _uploadDone)
              if (this._uploadDone) await this._uploadDone;
            } else if (this.videoChunks && this.videoChunks.length > 0) {
              // no active recording but we have chunks â€” upload directly
              await this.uploadRecordedVideo();
            }
          } catch (err) {
            console.error('finishAndUpload error:', err);
          } finally {
            // advance UI
            this.nextStep();
            // release camera resources now that user finished
            if (this.stream) {
              try {
                this.stream.getTracks().forEach(t => t.stop());
              } catch (e) { /* ignore */ }
              this.stream = null;
              const mini = document.getElementById('miniCam');
              if (mini) mini.srcObject = null;
            }
          }
        },
      },
      async mounted() {
        const params = new URLSearchParams(window.location.search);
        const id = params.get('id');
        if (!id) {
          window.location.href = '/gender-reveal/404.html';
          return;
        }
        this.clientId = id;
        // Check user existence in Supabase
        try {
          const { data, error } = await supabaseClient
            .from('users')
            .select('id')
            .eq('unique_link', id)
            .single();
            return;
          if (error || !data) {
            window.location.href = '/gender-reveal/404.html';
            return;
          }
        } catch (err) {
          window.location.href = '/gender-reveal/404.html';
          return;
        }
        // Request permission on mount so user sees the prompt immediately,
        // but don't start recording until they press Allow & Continue.
        try {
          this.uploadStatus = 'Requesting camera & mic permissionâ€¦';
          const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          this.stream = s;
          const mini = document.getElementById('miniCam');
          if (mini) mini.srcObject = s;
          this.uploadStatus = 'Camera ready';
        } catch (err) {
          console.warn('Permission on mount failed or was denied:', err);
          this.uploadStatus = 'Camera permission not granted';
        }
      }
    }).mount('#app');
   </script>
</body>

</html>